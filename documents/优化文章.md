# 优化文章

> 软件学院 高铭 22373386

[TOC]

受于时间限制，我的优化仅限于进行了中端的模运算优化，以及后端的虚拟寄存器转为实际寄存器的图着色优化。

## 1 中端模运算优化

我的模运算优化是在llvm中间代码生成时进行的，原理非常简单，能提升效率的地方也仅限于模运算，不过如果程序需要进行大量模运算，这个优化的效果还是十分可观的。

基本的原理就是，取模运算可以替换为形如下面的公式：
$$
x \% y = x - ( x / y ) * y
$$
在这个优化里面，只有右操作数是常量且为1才执行不执行这一算法，并不是在后续的MIPS中执行srem指令，而是为了后端的继续优化：不需要div+mfhi指令，只需要move $zero即可，因为任何数模1的值都是0。

具体的算法如下：

```java
if (op.getType() == TokenType.MOD) {
    // 取模可以替换为公式：x % y = x - ( x / y ) * y
    if (opRight instanceof ConstInt && ((ConstInt) opRight).getValue() == 1) {
        IrContext.synValue = IrBuilder.buildSremInstruction(opLeft, opRight, IrContext.curBlock);
    } else {
        // div = x / y
        Sdiv div = IrBuilder.buildSdivInstruction(opLeft, opRight, IrContext.curBlock);
        // mul = div * y = ( x / y ) * y
        Mul mul = IrBuilder.buildMulInstruction(div, opRight, IrContext.curBlock);
        // 最后结果 = x - mul
        IrContext.synValue = IrBuilder.buildSubInstruction(opLeft, mul, IrContext.curBlock);
    }
}
```



## 2 图着色优化

图着色优化是我花费时间最长，也是效果最好的优化方法。但是，对于testcase1，图着色算法的效果并不显著，甚至使得我在这个点上的排名低得离谱，猜测是因为没有做mem2reg优化导致的。

按照教程的介绍，图着色优化共分为7步：1. 构造（build）；2. 简化（simplify）；3. 合并（coalesce）；4. 冻结（freeze）；5. 溢出（spill）；6. 选择（select）；7. 重新开始（restart）。

我的图着色也是按照这七步来的。

### 2.0 公式说明

图着色问题的核心目标是为图中的每个节点分配不同的颜色（即寄存器），而相邻的节点（即冲突的变量）不能使用相同的颜色。在此背景下，以下公式为图着色中的一些关键概念提供了数学依据：

- **度数**：每个节点的度数 `deg(u)` 表示节点 `u` 与其他节点相连的边的数量。节点的度数决定了它在图着色中的优先级，度数越高的节点越难分配颜色。
  $$
  deg(u)=number\;of \;edges\; incident\; to\; node\; u
  $$

- **冲突图**：图着色问题可以通过构建冲突图来表示，其中每个节点代表一个变量，每条边表示两个变量之间存在冲突。冲突的变量不能分配相同的寄存器。
  $$
  G=(V,E)
  $$
  其中，`V` 是节点集合，`E` 是边集合。

- **寄存器分配**：每个变量（节点）需要被分配一个寄存器（颜色）。分配的规则是相邻的节点不能有相同的寄存器。
  $$
  \forall u, v \in V, \text{ if } (u, v) \in E \text{, then } \text{color}(u) \neq \text{color}(v)
  $$

### 2.1 构造（Build）

构造阶段的主要任务是生成 **冲突图**，这个图用于表示哪些变量不能在同一时刻使用同一个寄存器。我们通过数据流分析来计算在每条指令执行时同时活跃的临时变量。这些活跃的临时变量会被视为图中的节点，节点之间的边表示这些变量之间存在冲突。具体来说，在指令执行时，如果两个临时变量在同一时刻活跃（例如，一个变量在某条指令中被定义，而另一个变量在该指令之前就被使用），那么它们就会形成冲突。

数据流方程如下：
$$
in[m]=use[m]∪(out[n]−def[n])\\
out[n]=∪_{s∈succ[n]}in[s]
$$

- **in[m]**：表示在基本块的入口处活跃的变量集合。
- **out[n]**：表示从基本块 `n` 到所有后继基本块的活跃变量集合。

通过数据流分析可以得到每条指令中的活跃变量集合，并且可以进一步构建冲突图。具体地，对于每个基本块，分析其所有指令，构建出 **活跃变量集合**，并通过冲突图表达这些变量之间的冲突。

对于以下代码：

```assembly
add $2, $2, $3               #1
sw $4, 0($5)                 #2
```

在第一条指令 `add $2, $2, $3` 中，\$2 和 \$3 会成为活跃变量。而第二条指令 `sw $4, 0($5)` 的寄存器 \$4 和 \$5 与第一条指令的 \$2 形成冲突。因此，\$2、\$4 和 \$5 在图中将形成边。

### 2.2 简化（Simplify）

简化阶段的目标是通过启发式方法减少冲突图的复杂度。在此阶段，节点的度数（即与之相邻的节点数）较小的节点会被从冲突图中删除，并压入栈中。这些节点对应的寄存器可以被分配物理寄存器。简化操作的关键是：如果一个节点的度数小于通用寄存器的数量 `K`，即使它与其他节点存在冲突，也可以安全地将其从冲突图中移除并压栈。此操作有助于减少冲突图的度数，从而为后续的合并和选择步骤提供更多机会。

- 对于度数小于 `K` 的节点，将其移除，并将其加入栈中，以便后续的选择步骤为其分配物理寄存器。
- 简化操作会降低图的度数，产生更多可着色的节点，直到没有更多可简化的节点。

假设有一个节点 `m`，如果其度数小于 `K`，则可以简化：

```java
private void doSimplify() {
    MipsOperand u = simplifyList.iterator().next();
    simplifyList.remove(u);
    freezeMoves(u);
}
```

### 2.3 合并（Coalesce）

合并阶段主要处理 **move 指令**（如 `move $2, $3`），即两个操作数实际上是相同的。在这种情况下，可以将这两个寄存器合并为一个，从而避免生成冗余的 `move` 指令。合并操作有助于减少最终代码中的移动指令数量，提高程序性能。

然而，合并时需要特别小心。如果合并后的节点的度数变得太高（即度数大于等于 `K`），可能会导致新的冲突，这会适得其反。因此，合并操作需要在保证不会增加冲突的前提下进行。

合并策略为，在合并操作中，只合并那些可以保持度数小于 `K` 的节点。合并操作要确保合并后的节点不会变得过于复杂（度数过高）。

```java
private void coalesce() {
    // 选择可以合并的节点
    MipsOperand u = mergableMoves.iterator().next();
    merge(u);
}
```

### 2.4 冻结（Freeze）

冻结阶段处理那些无法合并的高度数节点。如果一个节点不能进行合并，但其度数小于 `K`，则可以将其“冻结”。冻结操作将该节点从简化操作中移除，直接进入后续的简化阶段。冻结操作有助于减少度数过高的节点，进一步简化图着色过程。

```java
private void doFreeze() {
    MipsOperand u = freezeList.iterator().next();
    freezeList.remove(u);
    simplifyList.add(u);
    freezeMoves(u);
}
```

### 2.5 溢出（Spill）

在简化和合并操作之后，冲突图中可能还会有一些度数较高的节点。这些节点无法直接着色，因此需要将它们存入内存中进行处理，称为 **溢出**。溢出的变量会被移出冲突图，存入栈中，从而降低其在后续操作中的度数。我们选择度数较高的节点，将其溢出到内存中（即栈中）。溢出的变量的活跃范围缩小，从而可以继续进行简化。

```java
private void doSelectSpill() {
    MipsOperand m = spillList.stream().max((l, r) -> {
        // 根据一定的策略选择溢出节点
        return Double.compare(magicNum(l), magicNum(r));
    }).get();
    simplifyList.add(m);
    freezeMoves(m);
    spillList.remove(m);
}
```

### 2.6 选择（Select）

选择阶段处理栈中已简化的节点，为它们分配物理寄存器。在选择时，节点必须满足可着色的条件，即该节点的邻接节点的颜色数目小于可用的物理寄存器数量 `K`。如果节点满足条件，就可以为其分配一个寄存器。

选择条件如下：

- 节点的邻接节点的颜色数目必须小于 `K`。
- 若节点无法着色，则会被加入到无法着色的集合中，并进行溢出处理。

```java
private void assignColors(MipsFunction func) {
    HashMap<MipsOperand, MipsOperand> colored = new HashMap<>();
    while (!selectStack.isEmpty()) {
        MipsOperand n = selectStack.pop();
        // 为节点n分配寄存器
        assignColorToNode(n, colored);
    }
}
```

### 2.7 重新开始（Restart）

如果在选择阶段无法为某些节点着色，则需要进行重新开始。这意味着对于这些无法着色的节点，我们需要将它们存入内存，并在程序运行时进行栈访问。这一过程会导致溢出的临时变量转化为新的活跃变量，需要重新进行寄存器分配。

```java
private void rewriteProgram(MipsFunction func) {
    for (MipsOperand n : spilledNodes) {
        // 处理溢出寄存器，替换为栈中的虚拟寄存器
        handleSpilledRegister(n);
    }
}
```